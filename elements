source/et_color_panel.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/et_color_panel.c:		if(!pv_element_kind_is_viewable_object(focus->elements[i]->kind)){
source/et_color_panel.c:			color_pair = focus->elements[i]->color_pair;
source/et_color_panel.c:					focus->elements[i]->color_pair.colors[PvColorPairGround_ForGround])){
source/et_color_panel.c:					focus->elements[i]->color_pair.colors[PvColorPairGround_BackGround])){
source/et_color_panel.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/et_color_panel.c:		focus->elements[i]->color_pair.colors[self->color_pair_ground]
source/et_position_panel.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/et_position_panel.c:		if(!pv_element_kind_is_viewable_object(focus->elements[i]->kind)){
source/et_position_panel.c:		const PvElementInfo *info = pv_element_get_info_from_kind(focus->elements[i]->kind);
source/et_position_panel.c:		PvRect rect_ = info->func_get_rect_by_anchor_points(focus->elements[i]);
source/et_position_panel.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/et_position_panel.c:		const PvElementInfo *info = pv_element_get_info_from_kind(focus->elements[i]->kind);
source/et_position_panel.c:		bool ret = info->func_move_element(focus->elements[i],
source/et_snap_panel.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/et_snap_panel.c:		if(!pv_element_kind_is_viewable_object(focus->elements[i]->kind)){
source/et_snap_panel.c:			snap = focus->elements[i]->snap;
source/et_snap_panel.c:			if(!pv_snap_is_equal(snap, focus->elements[i]->snap)){
source/et_snap_panel.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/et_snap_panel.c:		focus->elements[i]->snap = self->snap;
source/et_stroke_panel.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/et_stroke_panel.c:		if(!pv_element_kind_is_viewable_object(focus->elements[i]->kind)){
source/et_stroke_panel.c:			stroke = focus->elements[i]->stroke;
source/et_stroke_panel.c:			if(!pv_stroke_is_equal(stroke, focus->elements[i]->stroke)){
source/et_stroke_panel.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/et_stroke_panel.c:		focus->elements[i]->stroke = self->stroke;
source/et_tool_info.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/et_tool_info.c:		PvElement *element = focus->elements[i];
source/et_tool_info.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/et_tool_info.c:		PvElement *element = focus->elements[i];
source/et_tool_info.c:	PvElement **elements = focus->elements;
source/et_tool_info.c:		int num = pv_general_get_parray_num((void **)focus->elements);
source/et_tool_info.c:			_src_extent_rect = _get_rect_extent_from_elements(focus->elements);
source/et_tool_info.c:				size_t num_ = pv_general_get_parray_num((void **)focus->elements);
source/et_tool_info.c:					PvElement *element = focus->elements[i];
source/et_tool_info.c:		PvRect _after_extent_rect = _get_rect_extent_from_elements(focus->elements);
source/et_tool_info.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/et_tool_info.c:		const PvElementInfo *info = pv_element_get_info_from_kind(focus->elements[i]->kind);
source/et_tool_info.c:			PvAnchorPoint prev = info->func_get_anchor_point(focus->elements[i], focus->index);
source/et_tool_info.c:			info->func_set_anchor_point_point(focus->elements[i], focus->index, mouse_action.point);
source/et_tool_info.c:			info->func_move_anchor_point_point(focus->elements[i], focus->index, move);
source/et_tool_info.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/et_tool_info.c:	PvElement *element = focus->elements[0];
source/et_tool_info.c:	assert(focus->index < num_ap);
source/et_tool_info.c:	PvAnchorPoint *ap = pv_bezier_get_anchor_point_from_index(data->bezier, focus->index);
source/et_tool_info.c:	const PvElementInfo *info = pv_element_get_info_from_kind(focus->elements[0]->kind);
source/et_tool_info.c:	et_assertf(info, "%d", focus->elements[0]->kind);
source/et_tool_info.c:	int num = info->func_get_num_anchor_point(focus->elements[0]);
source/et_tool_info.c:		const PvAnchorPoint ap_ = info->func_get_anchor_point(focus->elements[0], i);
source/et_tool_info.c:			pv_focus_clear_set_element_index(focus, focus->elements[0], i);
source/main.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/main.c:	memcpy(elements_prefocus, focus->elements, sizeof(PvElement *) * (num + 1));
source/pv_element_info.c:		int ofs_index = (i - focus->index);
source/pv_element_info.c:		if(-1 != focus->index){
source/pv_element_info.c:			if(0 == focus->index && i == ((int)num - 1) && pv_bezier_get_is_close(simplify_data->bezier)){
source/pv_element_info.c:		PvElementPointKind kind = ((i == focus->index)?
source/pv_focus.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/pv_focus.c:		switch(focus->elements[0]->kind){
source/pv_focus.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/pv_focus.c:		if(element == focus->elements[i]){
source/pv_focus.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/pv_focus.c:		PvElement **elements = realloc(focus->elements, sizeof(PvElement *) * (num + 2));
source/pv_focus.c:		focus->elements = elements;
source/pv_focus.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/pv_focus.c:	if(1 == num && focus->elements[0] == element){
source/pv_focus.c:		if(element == focus->elements[i]){
source/pv_focus.c:			memmove(&focus->elements[i], &focus->elements[i + 1],
source/pv_focus.c:			focus->elements[num - 1] = NULL;
source/pv_focus.c:	int num = pv_general_get_parray_num((void **)focus->elements);
source/pv_focus.c:	return focus->elements[0];
source/pv_focus.c:	PvElement **new = realloc(focus->elements, sizeof(PvElement *) * 2);
source/pv_focus.c:	if(NULL == focus->elements){
source/pv_focus.c:	focus->elements = new;
source/pv_focus.c:	focus->index = index;
source/pv_focus.c:	free(focus->elements);
source/pv_renderer.c:		int num = pv_general_get_parray_num((void **)focus->elements);
source/pv_renderer.c:			const PvElement *focus_element = focus->elements[i];
work/et_focus_rel.c:	int num = pv_general_get_parray_num((void **)focus->elements);
work/et_focus_rel.c:		if(PvElementKind_Root == focus->elements[i]->kind){
work/et_focus_rel.c:		self->element_rels[i] = et_element_rel_new(focus->elements[i]);
